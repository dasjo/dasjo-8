<?php
/**
 * @file
 * Allows administrators to attach custom fields to fieldable types.
 */

// namespace Drupal\field_group;
// use Drupal\field_group\Plugin\Core\Entity;
use Drupal\Component\Uuid\Uuid;
// use Drupal\field_group\Plugin\field\widget\TestWidget;
// use Drupal\field_group\Plugin\Core\Entity\FieldGroup;
use Drupal\field_group\FieldGroup;
// use Drupal\field_group\Plugin\field_group\Div;
use Drupal\field_group\FieldGroupAddGroup;
use Drupal\field_group\FieldGroupFieldUi;

use Drupal\Core\Template\Attribute;

// use Drupal\field_group\Plugin\FieldGroupPluginManager;

use Drupal\Core\Entity\EntityManager;


function field_group_form_alter(&$form, &$form_state, $form_id) {
  // dsm($form);
  // dsm($form['fields']['field_image']['settings_edit']);
  // print'<pre>';print_r($form['fields']['field_image']['settings_edit']);print'</pre>';
}


// MANAGE DISPLAY: field_ui_display_overview_form
function field_group_form_field_ui_display_overview_form_alter(&$form, &$form_state, $form_id) {
  field_group_admin_form($form, $form_state, $form_id);
}
// FORM MANAGE DISPLAY: field_ui_form_display_overview_form
function field_group_form_field_ui_form_display_overview_form_alter(&$form, &$form_state, $form_id) {
  field_group_admin_form($form, $form_state, $form_id);
}

function field_group_admin_form(&$form, &$form_state, $form_id) {

  $entity_type = $form['#entity_type'];
  $bundle = $form['#bundle'];
  $display_mode = ($form_id == 'field_ui_display_overview_form') ? 'view' : FALSE;
  $display_mode = ($form_id == 'field_ui_form_display_overview_form') ? 'form' : $display_mode;
  $view_mode = $form['#mode'];


  $field_group_field_ui = new FieldGroupFieldUi($entity_type, $bundle, $display_mode, $view_mode);
  $field_groups = $field_group_field_ui->getFieldGroups();

  // Add add_fieldgroup form element.
  $form['fields']['_add_new_field_group'] = $field_group_field_ui->field_group_add_group();
  // We need to add _add_new_field_group to the regions array, otherwise it won't be displayed.
  $form['fields']['#regions']['hidden']['rows_order'][] = '_add_new_field_group';



  // Attach field_groups.
  $form['#field_groups'] = array();
  foreach ($field_groups as $field_group_id => $field_group) {
    $field_group_instance = $field_group_field_ui->getFieldgroupInstance($form, $form_state, $field_group);
    $form['#field_groups'][$field_group->field_group_name] = $field_group_instance;
    $form['fields'][$field_group->field_group_name] = $field_group_instance;
  }


  // TODO: THis needs to be generic. Looks like a huge amount of work -.-"
  // This should be equal to updateSettingsForm().
  if(isset($form_state['plugin_settings'])) {
    foreach ($field_groups as $field_group_id => $field_group) {
      if(isset($form_state['plugin_settings'][$field_group->field_group_name])) {
        $field_group_field_ui->submitSettingsForm($field_group, $form_state['plugin_settings'][$field_group->field_group_name]);
      }
    }
  }

  foreach ($field_groups as $field_group_id => $field_group) {
    if($form_state['plugin_settings_edit'] == $field_group->field_group_name) {

      $testfield = $field_group->field_group_name;

      $insance = Drupal::service('plugin.manager.field_group')->createInstance('fieldset');
      $settings_form = $insance->settingsForm($form, $form_state);

      // Get default settings.
      if($field_group->field_group_name == $testfield) {
        foreach($field_group->plugin_settings as $key => $value) {
          $settings_form[$key]['#default_value'] = $value;
        }
      }
      unset($form['fields'][$testfield]['plugin']['type']);
      // $form['fields']['field_group_what_about_that']['plugin']['settings_edit_form'] = $settings;


      $field_id = $testfield;
      // Base button element for the various plugin settings actions.
      $base_button = array(
        '#submit' => array(
          array($form_state['build_info']['callback_object'], 'multistepSubmit'),
        ),
        '#ajax' => array(
          'callback' => array($form_state['build_info']['callback_object'], 'multistepAjax'),
          'wrapper' => 'field-display-overview-wrapper',
          'effect' => 'fade',
        ),
        '#field_name' => $field_id,
      );

      $form['fields'][$testfield]['plugin']['settings_edit_form'] += array(
        '#type' => 'container',
        '#attributes' => array('class' => array('field-plugin-settings-edit-form')),
        '#parents' => array('fields', $field_id, 'settings_edit_form'),
        'label' => array(
          '#markup' => t('Plugin settings'),
        ),
        'settings' => $settings_form,
        'actions' => array(
          '#type' => 'actions',
          'save_settings' => $base_button + array(
            '#type' => 'submit',
            '#name' => $field_id . '_plugin_settings_update',
            '#value' => t('Update'),
            '#op' => 'update',
          ),
          'cancel_settings' => $base_button + array(
            '#type' => 'submit',
            '#name' => $field_id . '_plugin_settings_cancel',
            '#value' => t('Cancel'),
            '#op' => 'cancel',
            // Do not check errors for the 'Cancel' button, but make sure we
            // get the value of the 'plugin type' select.
            '#limit_validation_errors' => array(array('fields', $field_id, 'type')),
          ),
        ),
      );
      $form['fields'][$testfield]['plugin']['#cell_attributes'] = array(
        'colspan' => 3,
      );
      unset($form['fields'][$testfield]['settings_edit']);
      unset($form['fields'][$testfield]['settings_summary']);
    }

  }


  // Add the parent parameters.
  foreach ($field_groups as $field_group_id => $field_group) {
    if(!empty($field_group->fields)) {
      foreach ($field_group->fields as $delta => $field_name) {
        if($field_name != $field_group->field_group_name && isset($form['fields'][$field_name])) {
          $form['fields'][$field_name]['parent_wrapper']['parent']['#value'] = $field_group->field_group_name;
        }
      }
    }
  }


  // Prepare options to make them draggable to field_groups.
  $options = array();
  foreach($field_groups as $field_group) {
    $options[$field_group->field_group_name] = $field_group->field_group_name;
  }
  // Add _add_new_field_group to options, to be able to nest fields on-the-flow.
  $options['_add_new_field_group'] = '_add_new_field_group';
  // Add options to the fields.
  $draggable_fields = $field_group_field_ui->getDraggableFields($form);
  foreach($draggable_fields as $field_name) {
    if(isset($form['fields'][$field_name])) {
      $form['fields'][$field_name]['parent_wrapper']['parent']['#options'] = $options;
    }
  }


  // TODO: get rid of the extra object.
  $field_group_field_ui = new FieldGroupFieldUi($entity_type, $bundle, $display_mode, $view_mode);
  $form['#submit'][] = array($field_group_field_ui, 'submitForm');
}


/**
 * Render API callback: Checks if a field machine name is taken.
 *
 * @param $value
 *   The machine name, not prefixed with 'field_group_'.
 *
 * @return
 *   Whether or not the field machine name is taken.
 */
function _field_group_field_name_exists($value) {
  // Prefix with 'field_'.
  if(empty($value)) {
    return FALSE;
  }
  $field_name = 'field_group_' . $value;

  $exists = Drupal::entityQuery('field_group')
   ->condition('field_group_name', $value)
   ->execute();
   // TODO: This is not working yet.
  if(!empty($exists)) {
    return TRUE;
  }
  return FALSE;
}


function field_group_field_overview_row_region($row) {
  // dsm($row['#row_type']);
  switch ($row['#row_type']) {
    case 'field_group':
      return 'content';
    case 'feld_group2':
  }
}


// TODO: Get groups by entity/bundle/form:display/
// TODO: Merge this into field_Group class, this is pretty messy! Shame on me.
function field_group_get_field_groups($entity_type, $bundle, $view_mode) {

  $id = $entity_type . '.' . $bundle . '.' . $view_mode;
  $field_groups = Drupal::entityQuery('field_group')
   ->condition('entity_type', $entity_type)
   ->condition('bundle', $bundle)
   ->condition('mode', $view_mode)
   ->execute();
   // dsm($field_groups);

  if(isset($field_groups)) {
    $groups = $field_groups;
  }
  else {
    $groups = array();
  }
  $field_groups = array();
  // foreach(element_children($groups) as $delta => $group_name) {
  //   $field_groups[$group_name] = $group_name;
  // }
  $field_groups = $groups;
  return $field_groups;
}


function field_group_get_field_groups_keys($entity_type, $bundle, $view_mode, $filter = FALSE) {
  $groups = field_group_get_field_groups($entity_type, $bundle, $view_mode);
  if(isset($filter)) {
    unset($groups[$filter]);
  }
  return $groups;
}


function field_group_field_group_format_settings() {
  dsm('field_group_field_group_format_settings');
  dsm(get_defined_vars());
}





function field_group_entity_view(\Drupal\Core\Entity\EntityInterface $entity, \Drupal\entity\Plugin\Core\Entity\EntityDisplay $display, $view_mode, $langcode) {
  // Only do the extra work if the component is configured to be displayed.
  // This assumes a 'mymodule_addition' extra field has been defined for the
  // entity bundle in hook_field_extra_fields().
  // dsm($display);
  if ($display->getComponent('mymodule_addition')) {
    $entity->content['mymodule_addition'] = array(
      '#markup' => mymodule_addition($entity),
      '#theme' => 'mymodule_my_additional_field',
    );
  }
}

function field_group_entity_view_alter(&$build, Drupal\Core\Entity\EntityInterface $entity, \Drupal\entity\Plugin\Core\Entity\EntityDisplay $display) {
  // Attach groups to entity_view.
  field_group_attach_groups($build, $entity, $display);
  // dsm($build);


  // dsm($entity);
  // dsm($display);
}

// TODO: Put output into fieldgroups here!
function field_group_attach_groups(&$build, $entity, $display) {
  // dsm('field_group_attach_groups');
  // dvm($display->mode);
  // dsm(field_group_get_field_groups($entity->entityType(), $entity->bundle(), $display->mode));
  // dsm($build);

  // TODO: This should be the right view mode ;)
  $form = array();

  $entity_type = $display->targetEntityType;
  $bundle = $display->bundle;
  $display_mode = 'view';
  $view_mode = $display->mode;


  // $field_group = new FieldGroup($entity_type, $bundle, $display_mode, $view_mode);

  $field_group_field_ui = new FieldGroupFieldUi($entity_type, $bundle, $display_mode, $view_mode);

  foreach($field_group_field_ui->getFieldGroups() as $group_id => $group) {
    $build[$group->field_group_name] = array(
      '#type' => 'field_group',
      '#widget' => $group->type,
    );
    foreach ($group->fields as $delta => $field_name) {
      $build[$group->field_group_name][$field_name] = $build[$field_name];
      unset($build[$field_name]);
    }
  }

}


function template_preprocess_field_group__div(&$variables) {
  // TODO: We'll see, perheps nothing.
}
function template_preprocess_field_group__fieldset(&$variables) {
  // TODO: We'll see, perheps nothing.
}

function theme_field_group(&$variables) {
  $element = $variables['element'];
  $variables += array(
    'children' => $element['#children']
  );
  return theme('field_group__' . $element['#widget'], $variables);
}

function field_group_theme() {
  return array(
    'field_group' => array(
      'render element' => 'element',
    ),
    // TODO: Generate theme function for each widget plugin.
    'field_group__div' => array(
      'render element' => 'element',
      'template' => 'field-group--div',
    ),
    'field_group__fieldset' => array(
      'render element' => 'element',
      'template' => 'field-group--fieldset',
    ),
  );
}



/**
 * Implementation of hook_element_info().
 */
function field_group_element_info() {
  $types = array();
  $types['field_group'] = array(
    '#theme_wrappers' => array('field_group'),
  );

  return $types;
}


